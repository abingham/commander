#!/bin/sh

# Controls a cyber-dojo web server.
# requires: grep which is in DockerToolbox Quickstart Terminal.
#
# Most commands forward to, and run inside, the cyber-dojo
# commander container. However, a few commands are handled
# locally, on the host server, outside of the container, viz:
#
#  1) ./cyber-dojo sh ...
#  2) ./cyber-dojo update ...
#  3) ./cyber-dojo start-point create ...
#
#  1) provides an interactive terminal.
#  2) ends by replacing this script.
#  3) may access local DIRs.
#
# Re 1: the docker run command could take --interactive --tty
# options which should enable the sh command to be handled
# by the commander container. Trying this out briefly shows
# that it affects the captured output (trailing \r \n) which
# breaks the sh tests.
#
# Re 3: If you're running Docker-Toolbox and are in the terminal
# it will check the DIR __locally__ (eg on the Mac) but the
# volume-mount will of course take place where the docker-daemon
# is running, which will be on the default VM
# (thanks to the DOCKER_HOST et al env-vars).
# In this case ensure the DIR is under /Users/<user> so it
# will be in the default VM so the volume mount will work.

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

on_Mac()
{
  # https://stackoverflow.com/questions/394230
  [[ "$OSTYPE" == "darwin"* ]]
}

not_using_DockerToolbox()
{
  [[ -z "${DOCKER_MACHINE_NAME}" ]]
}

if not_using_DockerToolbox; then
  if on_Mac; then
    echo 'ERROR'
    echo 'On a Mac you must use Docker Toolbox.'
    echo 'Maybe you need to run:'
    echo '$ eval $(docker-machine env)'
    exit 1
  fi
fi

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

readonly my_dir="$( cd "$( dirname "$0" )" && pwd )"
readonly cyber_dojo_commander=cyberdojo/commander

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

error()
{
  >&2 echo "ERROR: ${2}"
  exit "${1}"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

exit_non_zero_unless_git_installed()
{
  local git="${GIT_PROGRAM:-git}"
  if ! hash "${git}" 2> /dev/null; then
    error 1 'git is not installed!'
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

exit_non_zero_unless_docker_installed()
{
  local docker="${DOCKER_PROGRAM:-docker}"
  if ! hash "${docker}" 2> /dev/null; then
    error 2 'docker is not installed!'
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

delegate_to_commander()
{
  if [ "$1" = 'up' ];  then
    set_env_file_volumes
  fi
  # shellcheck disable=SC2086
  # 2086 == Double quote to prevent globbing and word splitting.
  # CYBER_DOJO_ENV_ROOT must match Dockerfile
  docker run \
    --init \
    --rm \
    --interactive \
    --user=root \
    --env CYBER_DOJO_SH_ROOT="${my_dir}" \
    --env CYBER_DOJO_ENV_ROOT=/tmp/app \
    --volume=/var/run/docker.sock:/var/run/docker.sock \
    ${volume_grafana_env_file} \
    ${volume_nginx_env_file} \
    ${volume_web_env_file} \
      "${cyber_dojo_commander}" \
        /app/cmd/cyber-dojo.rb ${debug_option} "$@"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

set_env_file_volumes()
{
  # web:env_file: in docker-compose.yml
  local web_env="${my_dir}/web.env"
  if [ -f "${web_env}" ];  then
    volume_web_env_file="--volume=${web_env}:${web_env}:ro"
  fi
  # nginx:env_file: in docker-compose.yml
  local nginx_env="${my_dir}/nginx.env"
  if [ -f "${nginx_env}" ];  then
    volume_nginx_env_file="--volume=${nginx_env}:${nginx_env}:ro"
  fi
  # grafana:env_file: in docker-compose.yml
  local grafana_env="${my_dir}/grafana.env"
  if [ -f "${grafana_env}" ];  then
    volume_grafana_env_file="--volume=${grafana_env}:${grafana_env}:ro"
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

readonly MY_NAME=$(basename "${0}")
readonly IMAGE_NAME="${3}"
readonly IMAGE_TYPE="${4}"
declare -ar GIT_REPO_URLS="(${@:5})"

handle_start_point_create_locally()
{
  if [ "$1 $2" != 'start-point create' ]; then
    return
  fi
  exit_zero_if_show_use "${@}"
  exit_non_zero_if_bad_args "${@}"
  exit_non_zero_unless_git_installed
  prepare_context_dir
  git_clone_urls_into_context_dir
  build_image_from_context_dir
}

# - - - - - - - - - - - -

exit_zero_if_show_use()
{
  if [ "${3}" = '' ] || [ "${3}" = '-h' ] || [ "${3}" = '--help' ]; then
    show_use
    exit 0
  fi
}

# - - - - - - - - - - - -

show_use()
{
  cat <<- EOF

  Use:
  \$ ./${MY_NAME} start-point create <name> --custom    <url>...
  \$ ./${MY_NAME} start-point create <name> --exercises <url>...
  \$ ./${MY_NAME} start-point create <name> --languages <url>...

  Creates a cyber-dojo start-point image named <name>
  Its base image will be cyberdojo/start-points-base
  It will contain git clones of all the specified git-repo <url>s

  Example 1: local git-repo url

  \$ ./${MY_NAME} start-point create \\
        eg/first \\
          --custom \\
            file:///.../yahtzee

  Example 2: non-local git-repo <url>

  \$ ./${MY_NAME} start-point create \\
        eg/second \\
          --exercises \\
            https://github.com/.../my-exercises.git

  Example 3: multiple git-repo <url>s

  \$ ./${MY_NAME} start-point create \\
        eg/third \\
          --languages \\
            file:///.../asm-assert \\
            https://github.com/.../my-languages.git

  Example 4: read git-repo <url>s from a curl'd file

  \$ ./${MY_NAME} start-point create \\
        eg/fourth \\
          --languages \\
            \$(curl --silent https://raw.githubusercontent.com/.../url_list/all)

  Example 5: read git-repo <url>s from a local file

  \$ ./${MY_NAME} start-point create \\
        eg/fifth \\
          --languages \\
            \$(< my-language-selection.txt)

  \$ cat my-language-selection.txt
  https://github.com/.../java-junit.git
  https://github.com/.../javascript-jasmine.git
  https://github.com/.../python-pytest.git
  https://github.com/.../ruby-minitest.git

EOF
}

# - - - - - - - - - - - -

exit_non_zero_if_bad_args()
{
  local args="${@:3}"
  set +e
  docker container run --rm $(base_image_name) \
    /app/src/from_script/bad_args.rb ${args}
  local status=$?
  set -e
  if [ "${status}" != '0' ]; then
    exit "${status}"
  fi
}

# - - - - - - - - - - - -

CONTEXT_DIR=''

prepare_context_dir()
{
  CONTEXT_DIR=$(mktemp -d)
  trap remove_context_dir EXIT
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

remove_context_dir()
{
  rm -rf "${CONTEXT_DIR}" > /dev/null
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

git_clone_urls_into_context_dir()
{
  for url in "${GIT_REPO_URLS[@]}"; do
    git_clone_one_url_into_context_dir "${url}"
  done
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

URL_INDEX=0

git_clone_one_url_into_context_dir()
{
  # git-clone directly, from this script, into the
  # context dir before running [docker image build].
  # Viz, run [git clone] on the host rather than wherever
  # the docker daemon is (via a command in the Dockerfile).
  local url="${1}"
  cd "${CONTEXT_DIR}"
  local stderr
  if ! stderr="$(git clone --depth 1 "${url}" "${URL_INDEX}" 2>&1)"; then
    local newline=$'\n'
    local msg="BAD git clone <url>${newline}"
    msg+="${IMAGE_TYPE} ${url}${newline}"
    msg+="${stderr}"
    error 3 "${msg}"
  fi

  chmod -R +rX "${URL_INDEX}"
  local sha
  sha=$(cd ${URL_INDEX} && git rev-parse HEAD)
  echo "${IMAGE_TYPE} \t ${url}"
  echo "${URL_INDEX} \t ${sha} \t ${url}" >> "${CONTEXT_DIR}/shas.txt"
  rm -rf "${CONTEXT_DIR}/${URL_INDEX}/.git"
  rm -rf "${CONTEXT_DIR}/${URL_INDEX}/docker"
  # Two or more git-repo-urls could have the same repo name
  # but be from different repositories.
  # So git clone each repo into its own unique directory
  # based on a simple incrementing index.
  URL_INDEX=$((URL_INDEX + 1))
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

build_image_from_context_dir()
{
  case "$(image_type)" in
       'custom') PORT=4526;;
    'exercises') PORT=4525;;
    'languages') PORT=4524;;
  esac

  local env_vars="PORT=${PORT}"
  if [ -n "${SHA}" ]; then
    env_vars="${env_vars} SHA=${SHA}"
  fi
  {
    echo "FROM $(base_image_name)"
    echo "LABEL org.cyber-dojo.start-point=$(image_type)"
    echo "COPY . /app/repos"
    echo "RUN /app/src/from_script/check_all.rb /app/repos $(image_type)"
    echo "ENV ${env_vars}"
    echo "EXPOSE ${PORT}"
    echo 'CMD [ "./up.sh" ]'
  } > "${CONTEXT_DIR}/Dockerfile"
  echo "Dockerfile" > "${CONTEXT_DIR}/.dockerignore"
  local output
  if ! output=$(docker image build \
        --quiet                    \
        --tag "${IMAGE_NAME}"      \
        "${CONTEXT_DIR}" 2>&1)
  then
    # We are building FROM an image and we want any diagnostics
    # but we do not want the output from the [docker build] itself.
    # Hence the --quiet option.
    # On a Macbook using Docker-Toolbox stderr looks like this:
    #
    #   1 Sending build context to Docker daemon  185.9kB
    #   2 Step 1/N : FROM cyberdojo/start-points-base:latest
    #   3  ---> Running in fe6adeee193c
    #   ...
    #---5 ERROR: no manifest.json files in
    #---6 --custom file:///Users/.../custom_no_manifests
    #   7 The command '/bin/sh -c ...' returned a non-zero code: 16
    #
    # We want only lines 5,6
    # On CircleCI, stderr is not identical so the grep patterns are a little loose.

    echo "${output}" \
      | grep --invert-match 'Sending build context to Docker'  \
      | grep --invert-match '\-\-\-'                           \
      | grep --invert-match 'Step'                             \
      | grep --invert-match 'Removing intermediate container'  \
      | >&2 grep --invert-match "The command '/bin/sh -c"      \
      || :
    local last_line="${output##*$'\n'}"
    local last_word="${last_line##* }"
    exit "${last_word}" # eg 16
  else
    echo "Successfully built ${IMAGE_NAME}"
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

base_image_name()
{
  # Must be pushed to dockerhub in .circleci/config.yml
  echo 'cyberdojo/starter-base:latest'
}

image_type()
{
  echo "${IMAGE_TYPE:2}" # '--languages' => 'languages'
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

handle_sh_locally()
{
  if [ "$1" != "sh" ]; then
    return
  fi

  local arg="$2"
  local name="cyber-dojo-${arg}"
  if running_container "${name}"; then
    echo "shelling into ${name}"
    local cmd="export PS1='[${arg}] \\w $ ';sh"
    docker exec --interactive --tty "${name}" sh -c "${cmd}"
  elif [ "${arg}" != '--help' ] && [ "${arg}" != '' ]; then
    error 4 "${name} is not a running container"
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

running_container()
{
  local space='\s'
  local name="$1"
  local end_of_line='$'
  docker ps --filter "name=${name}" | grep "${space}${name}${end_of_line}" > /dev/null
  return $?
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

handle_update_locally()
{
  if [ "$1" != 'update' ]; then
    return
  fi
  if [ "$2" = '' ]; then
    replace_myself
  fi
  if [ "$2" = 'server' ] && [ "$3" = '' ]; then
    replace_myself
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

replace_myself()
{
  # See https://bani.com.br/2013/04/shell-script-that-updates-itself/
  local cid=$(docker create --interactive "${cyber_dojo_commander}" sh)
  docker cp "${cid}":/app/cyber-dojo /tmp
  docker rm "${cid}" > /dev/null
  local new_me=/tmp/cyber-dojo
  chmod +x "${new_me}"
  cp "${new_me}" "$0"
  rm "${new_me}"
}

#==========================================================

if [ "$1" = '--debug' ]; then
  debug_option='--debug'
  shift
fi

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

if [ "$1" = 'update' ]; then
  if [ "$2" = '' ]; then
    exit_non_zero_unless_docker_installed
    docker pull ${cyber_dojo_commander}
  fi
  if [ "$2" = 'server' ] && [ "$3" = '' ]; then
    exit_non_zero_unless_docker_installed
    docker pull ${cyber_dojo_commander}
  fi
fi

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

exit_non_zero_unless_docker_installed
if ! delegate_to_commander "$@"; then
  error 5 ''
fi

handle_start_point_create_locally "$@"
handle_sh_locally "$@"
handle_update_locally "$@"
