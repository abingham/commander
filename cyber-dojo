#!/bin/bash

# Controls a cyber-dojo web server.
# requires: grep which is in DockerToolbox Quickstart Terminal.
#
# Most commands forward to, and run inside, the cyber-dojo
# commander container. However, a few commands are handled
# locally, on the host server, outside of the container, viz:
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# $ ./cyber-dojo start-point create ...
#
# If you're running Docker-Toolbox then the git-repo-urls
# (being git-cloned into the docker-build context-dir)
# may not be volume-mounted into the default VM (they may not
# be under /Users/<user>) so the git-clones have to happen locally.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# $ ./cyber-dojo sh ...
#
# The docker run command could take --interactive --tty
# options which should enable the sh command to be handled
# by the commander container. Trying this out briefly shows
# that it affects the captured output (trailing \r \n) which
# breaks the sh tests.
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# $ ./cyber-dojo update ...
#
# Ends by replacing this script.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

on_Mac()
{
  # https://stackoverflow.com/questions/394230
  [[ "$OSTYPE" == "darwin"* ]]
}

not_using_DockerToolbox()
{
  [[ -z "${DOCKER_MACHINE_NAME}" ]]
}

if not_using_DockerToolbox; then
  if on_Mac; then
    echo 'ERROR'
    echo 'On a Mac you must use Docker Toolbox.'
    echo 'Maybe you need to run:'
    echo '$ eval $(docker-machine env)'
    exit 1
  fi
fi

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

readonly my_dir="$( cd "$( dirname "$0" )" && pwd )"
readonly cyber_dojo_commander=cyberdojo/commander

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

error()
{
  >&2 echo "ERROR: ${2}"
  exit "${1}"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

exit_non_zero_unless_docker_installed()
{
  local docker="${DOCKER_PROGRAM:-docker}"
  if ! hash "${docker}" 2> /dev/null; then
    error 2 'docker is not installed!'
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

delegate_to_commander()
{
  if [ "$1" = 'up' ];  then
    set_env_file_volumes
  fi
  # shellcheck disable=SC2086
  # 2086 == Double quote to prevent globbing and word splitting.
  # CYBER_DOJO_ENV_ROOT must match Dockerfile
  docker run \
    --init \
    --rm \
    --interactive \
    --user=root \
    --env CYBER_DOJO_CUSTOM \
    --env CYBER_DOJO_EXERCISES \
    --env CYBER_DOJO_LANGUAGES \
    --env CYBER_DOJO_PORT \
    --env CYBER_DOJO_ENV_ROOT=/tmp/app \
    --env CYBER_DOJO_SH_ROOT="${my_dir}" \
    --env RELEASE \
    --volume=/var/run/docker.sock:/var/run/docker.sock \
    ${volume_grafana_env_file} \
    ${volume_nginx_env_file} \
    ${volume_web_env_file} \
      "${cyber_dojo_commander}" \
        /app/cmd/cyber-dojo.rb ${debug_option} "$@"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

set_env_file_volumes()
{
  # web:env_file: in docker-compose.yml
  local web_env="${my_dir}/web.env"
  if [ -f "${web_env}" ];  then
    volume_web_env_file="--volume=${web_env}:${web_env}:ro"
  fi
  # nginx:env_file: in docker-compose.yml
  local nginx_env="${my_dir}/nginx.env"
  if [ -f "${nginx_env}" ];  then
    volume_nginx_env_file="--volume=${nginx_env}:${nginx_env}:ro"
  fi
  # grafana:env_file: in docker-compose.yml
  local grafana_env="${my_dir}/grafana.env"
  if [ -f "${grafana_env}" ];  then
    volume_grafana_env_file="--volume=${grafana_env}:${grafana_env}:ro"
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

handle_sh_locally()
{
  local arg="$2"
  local name="cyber-dojo-${arg}"
  if running_container "${name}"; then
    echo "shelling into ${name}"
    local cmd="export PS1='[${arg}] \\w $ ';sh"
    docker exec --interactive --tty "${name}" sh -c "${cmd}"
  elif [ "${arg}" != '--help' ] && [ "${arg}" != '-h' ] && [ "${arg}" != '' ]; then
    error 4 "${name} is not a running container"
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

running_container()
{
  local space='\s'
  local name="$1"
  local end_of_line='$'
  docker ps --filter "name=${name}" | grep "${space}${name}${end_of_line}" > /dev/null
  return $?
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

handle_update_locally()
{
  if [ "$2" = '' ]; then
    replace_myself
  fi
  if [ "$2" = 'server' ] && [ "$3" = '' ]; then
    replace_myself
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

replace_myself()
{
  # See https://bani.com.br/2013/04/shell-script-that-updates-itself/
  local cid=$(docker create --interactive "${cyber_dojo_commander}" sh)
  docker cp "${cid}":/app/cyber-dojo /tmp
  docker rm "${cid}" > /dev/null
  local new_me=/tmp/cyber-dojo
  chmod +x "${new_me}"
  cp "${new_me}" "$0"
  rm "${new_me}"
}

#==========================================================

if [ "$1" = '--debug' ]; then
  debug_option='--debug'
  shift
fi

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

if [ "$1" = 'update' ]; then
  if [ "$2" = '' ]; then
    exit_non_zero_unless_docker_installed
    docker pull ${cyber_dojo_commander}
  fi
  if [ "$2" = 'server' ] && [ "$3" = '' ]; then
    exit_non_zero_unless_docker_installed
    docker pull ${cyber_dojo_commander}
  fi
fi

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

exit_non_zero_unless_docker_installed
if ! delegate_to_commander "$@"; then
  exit 5
fi

if [ "$1 $2" = 'start-point create' ]; then
  script=cyber-dojo-start-point-create.sh
  docker run --rm -i cyberdojo/commander:latest \
    sh -c "cat /app/${script}" > /tmp/${script}
  chmod 700 /tmp/${script}
  /tmp/${script} $@
  exit $?
fi

if [ "$1" = "sh" ]; then
  handle_sh_locally "$@"
fi

if [ "$1" != 'update' ]; then
  handle_update_locally "$@"
fi
