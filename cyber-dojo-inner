#!/bin/bash

# - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# The main cyber-dojo script cats this out of a
# commander container and runs it locally.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Most commands delegate to a commander container.
# However, a few commands are currently handled locally,
# on the host; see by extract_and_run().
# - - - - - - - - - - - - - - - - - - - - - - - - - - - -

delegate_to_commander()
{
  check_env_file_exists CYBER_DOJO_GRAFANA_ENV "${CYBER_DOJO_GRAFANA_ENV}"
  check_env_file_exists CYBER_DOJO_NGINX_ENV   "${CYBER_DOJO_NGINX_ENV}"
  check_env_file_exists CYBER_DOJO_WEB_ENV     "${CYBER_DOJO_WEB_ENV}"

  docker run \
    --env CYBER_DOJO_CUSTOM \
    --env CYBER_DOJO_EXERCISES \
    --env CYBER_DOJO_LANGUAGES \
    --env CYBER_DOJO_PORT \
    --rm \
    --user=root \
    --volume=/var/run/docker.sock:/var/run/docker.sock \
    $(volume_env_file grafana "${CYBER_DOJO_GRAFANA_ENV}") \
    $(volume_env_file nginx   "${CYBER_DOJO_NGINX_ENV}") \
    $(volume_env_file web     "${CYBER_DOJO_WEB_ENV}") \
      "$(commander_image_name)" \
        /app/cmd/cyber-dojo.rb ${debug_option} "$@"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

commander_image_name()
{
  # Tests override COMMANDER_IMAGE (to use :latest)
  local -r VERSIONER_IMAGE=cyberdojo/versioner:latest
  local -r ENV_VARS=$(docker run --rm ${VERSIONER_IMAGE} sh -c 'cat /app/.env')
  local -r COMMANDER_VAR=$(echo "${ENV_VARS}" | grep 'CYBER_DOJO_COMMANDER_SHA')
  local -r COMMANDER_SHA=$(echo ${COMMANDER_VAR:25:99})
  local -r COMMANDER_TAG=${COMMANDER_SHA:0:7}
  local -r COMMANDER_IMAGE=${COMMANDER_IMAGE:-cyberdojo/commander:${COMMANDER_TAG}}
  echo "${COMMANDER_IMAGE}"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

check_env_file_exists() # $1=name $2=path
{
  if [ -n "${2}" ]; then
    if [ -z "${DOCKER_MACHINE_NAME}" ]; then
      check_env_file_exists_on_host "$@"
    else
      check_env_file_exists_on_target "$@"
    fi
  fi
}

check_env_file_exists_on_host() # $1=name $2=path
{
  if [ ! -f "${2}" ]; then
    >&2 echo "ERROR: env-var ${1} is set to ${2}"
    >&2 echo "but ${2} does not exist (on the host)"
    exit 3
  fi
}

check_env_file_exists_on_target() # $1=name $2=path
{
  if ! docker-machine ssh "${DOCKER_MACHINE_NAME}" "[ -f ${2} ]" 2> /dev/null; then
    >&2 echo "ERROR: env-var ${1} is set to ${2}"
    >&2 echo "but ${2} does not exist (on ${DOCKER_MACHINE_NAME} VM)"
    exit 3
  fi
}

volume_env_file()
{
  local -r name="${1}"
  local -r path="${2}"
  if [ -n "${path}" ]; then
    echo "--volume=${path}:/app/env_files/custom.${name}.env:ro"
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

extract_and_run()
{
  local -r script="${1}"
  shift
  docker run \
    --interactive \
    --volume=/var/run/docker.sock:/var/run/docker.sock \
    --rm \
    "$(commander_image_name)" \
    sh -c "/app/cmd/sh/cat-${script}" > /tmp/${script}
  chmod 700 /tmp/${script}
  /tmp/${script} $@
  exit $?
}

#==========================================================

if [ "$1" = '--debug' ]; then
  shift
  debug_option='--debug'
fi

if [ "$1 $2" = 'start-point create' ]; then
  extract_and_run start-point-create.sh "$@"
elif [ "$1" = 'sh' ]; then
  extract_and_run sh.sh "$@"
elif [ "$1" = 'update' ]; then
  extract_and_run update.sh "$@"
elif ! delegate_to_commander "$@"; then
  exit 5
fi

exit 0
