#!/bin/bash
set -e
# - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# The main cyber-dojo script cats this out of a
# commander container and runs it locally.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Most commands delegate to a commander container.
# However, a few commands are handled locally, on the host.
#   1) ./cyber-dojo start-point create NAME --custom <url>...
#      This is to allow the <url>s to be local.
#   2) ./cyber-dojo sh web
#      This is because the delegation is to a ruby script
#      and not a bash script.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - -

delegate_to_commander()
{
  exit_unless_env_file_exists CYBER_DOJO_NGINX_ENV "${CYBER_DOJO_NGINX_ENV}"
  exit_unless_env_file_exists CYBER_DOJO_WEB_ENV   "${CYBER_DOJO_WEB_ENV}"

  docker run \
    --env CYBER_DOJO_SWARM       \
    --env CYBER_DOJO_NGINX_IMAGE \
    --env CYBER_DOJO_NGINX_TAG   \
    --env CYBER_DOJO_NGINX_ENV   \
    --env CYBER_DOJO_WEB_IMAGE   \
    --env CYBER_DOJO_WEB_TAG     \
    --env CYBER_DOJO_WEB_ENV     \
    --env COMMANDER_TAG=$(commander_tag) \
    --rm \
    --user=root \
    --volume=/var/run/docker.sock:/var/run/docker.sock \
    $(volume_env_file nginx   "${CYBER_DOJO_NGINX_ENV}") \
    $(volume_env_file web     "${CYBER_DOJO_WEB_ENV}") \
      "$(commander_image):$(commander_tag)" \
        /app/cmd/cyber-dojo.rb ${debug_option} "$@"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
commander_image()
{
  # cyber-dojo has exported versioner's .env env-vars
  echo "${CYBER_DOJO_COMMANDER_IMAGE}"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
commander_tag()
{
   # cyber-dojo has exported versioner's .env env-vars
   echo "${COMMANDER_TAG:-${CYBER_DOJO_COMMANDER_TAG}}"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
exit_unless_env_file_exists()
{
  local -r name="${1}"
  local -r path="${2}"
  if [ -n "${path}" ]; then
    if [ -z "${DOCKER_MACHINE_NAME}" ]; then
      exit_unless_env_file_exists_on_host "${name}" "${path}"
    else
      exit_unless_env_file_exists_on_machine "${name}" "${path}"
    fi
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
exit_unless_env_file_exists_on_host()
{
  local -r name="${1}"
  local -r path="${2}"
  if [ ! -f "${path}" ]; then
    local -r where='on the host'
    echo_env_var_error "${name}" "${path}" "${where}"
    exit 3
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
exit_unless_env_file_exists_on_machine()
{
  local -r name="${1}"
  local -r path="${2}"
  if ! docker-machine ssh "${DOCKER_MACHINE_NAME}" "[ -f ${path} ]" 2> /dev/null; then
    local -r where="on VM '${DOCKER_MACHINE_NAME}'"
    echo_env_var_error "${name}" "${path}" "${where}"
    exit 4
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
echo_env_var_error()
{
  local -r name="${1}"
  local -r path="${2}"
  local -r where="${3}"
  >&2 echo 'ERROR: bad environment variable'
  >&2 echo "${name}=${path}"
  >&2 echo "does not exist (${where})"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
volume_env_file()
{
  local -r name="${1}"
  local -r path="${2}"
  if [ -n "${path}" ]; then
    echo "--volume=${path}:/app/env_files/custom.${name}.env:ro"
  fi
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
extract_and_run()
{
  # We want cat-start-point-create.sh to derive its
  # CYBER_DOJO_START_POINTS_BASE_IMAGE and
  # CYBER_DOJO_START_POINTS_BASE_TAG from versioner's /app/.env file.
  # However, there is one case where we don't want this.
  # That is when we are doing development on the
  # start-points-base repo and need this script to create start-point
  # images built from the local cyberdojo/start-points-base
  # image. See start-points-base/sh/build_test_derived_images.sh
  local -r script="${1}"
  shift
  docker run \
    --env CYBER_DOJO_START_POINTS_BASE_IMAGE=${CYBER_DOJO_START_POINTS_BASE_IMAGE} \
    --env CYBER_DOJO_START_POINTS_BASE_TAG=${CYBER_DOJO_START_POINTS_BASE_TAG} \
    --interactive \
    --volume=/var/run/docker.sock:/var/run/docker.sock \
    --rm \
    "$(commander_image):$(commander_tag)" \
    sh -c "/app/cmd/sh/cat-${script}" \
      > /tmp/${script}
  chmod 700 /tmp/${script}
  /tmp/${script} "$@"
  exit $?
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [ "$1" = '--debug' ]; then
  shift
  debug_option='--debug'
fi

if [ "$1 $2" = 'start-point create' ]; then
  extract_and_run start-point-create.sh "$@"
elif [ "$1" = 'sh' ]; then
  extract_and_run sh.sh "$@"
elif ! delegate_to_commander "$@"; then
  exit 5
fi

exit 0
